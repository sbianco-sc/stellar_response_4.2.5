import sys
import argparse
import requests
import logging
import time
import datetime
import json
import yaml

import utils

VALID_ACTIONS = ["contain_host", "lift_host_containment",
        "hide_host", "unhide_host"]

IP_TYPE_MAP = {
        "both": ["srcip", "dstip"],
        "srcip": ["srcip"],
        "dstip": ["dstip"]
}

class CrowdStrikeConnector:

    def __init__(self, tenant_id="", client_id="", password="",
            base_url="https://api.crowdstrike.com", lgr=None, **kwargs):
        """
        Object that creates the authorization headers for- and sends API requests to the Microsoft Office APIs'.
        :param tenant_id: tenant ID of of Office/Azure subscription
        :param client_id: ID of the application created in Azure to allow API access
        :param secret_key: key (secret) generated by the application created in Azure
        :param publisher_id: random GUID for API throttling
        """
        self.tenant_id = tenant_id
        self.client_id = client_id
        self.password = utils.aella_decode(utils.COLLECTOR_SECRET, password)
        self.expiration = 0
        self.base_url = base_url.rstrip('/') if (base_url and base_url != "https://") else "https://api.crowdstrike.com"
        if not self.base_url.startswith("https://"):
            self.base_url = "https://" + self.base_url
        self.logger = lgr
        self._headers = None
        self._proxy = utils.PROXY
        requests.packages.urllib3.disable_warnings()

    @property
    def headers(self):
        """
        Generate headers once then return from cache.
        :return: authorization headers to use in https requests
        """
        if not self._headers:
            self._headers = self.login()
        return self._headers

    def login(self):
        #self.password = self.password.replace('+', '%2B') if self.password else self.password
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        auth_url = utils.build_url(self.base_url, "/oauth2/token", logger=self.logger)
        data = 'grant_type=client_credentials&client_id={0}&client_secret={1}'.format(
            self.client_id, self.password)
        r = requests.post(auth_url, headers=headers, data=data, verify=False, proxies=self._proxy)
        resp = r.json()
        try:
            assert r.status_code / 100 == 2, str(resp.get("errors"))
            headers['authorization'] = 'bearer ' + resp['access_token']
            headers['Content-Type'] = 'application/json'
            headers['accept'] = 'application/json'
            return headers
        except Exception as e:
            error_msg = "Failed to log in to Crowdstrike: {}".format(str(e))
            if self.logger:
                self.logger.error(error_msg)
            raise Exception(error_msg)

    def prepare(self, action_name, settings, source):
        """
        Function used by Stellar Cyber for threat hunting integration
        :param action_name: str: function to call
        :param settings: obj: additional info that may be needed
        :param source: obj: threat hunting results
        :return: list of obj: list of parameters to call <action_name> with.
            Each object in the list represents one function call, so a list
            of length n will result in n separate calls
        """
        params = []
        if action_name in VALID_ACTIONS:
            for hit in source["ctx"]["payload"]["filtered"]:
                hit_src = hit["_source"]
                for ip_type in IP_TYPE_MAP[settings.get("ip_type")]:
                    cidr = hit_src.get(ip_type)
                    if not cidr:
                        continue
                    params.append({"cidr": cidr})
        return params

    def test_connection(self, **kwargs):
        try:
            if self.headers:
                return utils.create_response("CrowdStrike", 200, "")
        except Exception as e:
            return utils.create_response("CrowdStrike", 400, str(e))

    def contain_host(self, cidr=None, host_id=None, **kwargs):
        return self.run_crowdstrike_action(
                "contain", cidr=cidr, host_id=host_id)

    def lift_host_containment(self, cidr=None, host_id=None, **kwargs):
        return self.run_crowdstrike_action(
                "lift_containment", cidr=cidr, host_id=host_id)

    def hide_host(self, cidr=None, host_id=None, **kwargs):
        host_id, is_hidden = self.get_host_info(cidr=cidr, host_id=host_id)
        if is_hidden:
            return {"result_msg": "No action taken. Host is already hidden."}
        return self.run_crowdstrike_action(
                "hide_host", cidr=cidr, host_id=host_id)

    def unhide_host(self, cidr=None, host_id=None, **kwargs):
        host_id, is_hidden = self.get_host_info(cidr=cidr, host_id=host_id)
        if not is_hidden:
            return {"result_msg": "No action taken. Host is already unhidden."}
        return self.run_crowdstrike_action(
                "unhide_host", cidr=cidr, host_id=host_id)

    def run_crowdstrike_action(self, action, cidr=None, host_id=None):
        if cidr is None and host_id is None:
            raise Exception("Missing target host info")
        if host_id is None:
            host_id, _ = self.get_host_info(cidr=cidr)
        reply = self.call_crowdstrike_action(ids=host_id, action=action)
        return self.extract_message_from_action_reply(reply)

    def get_host_info(self, cidr=None, host_id=None):
        # Returns a (host_id, is_hidden) tuple
        if host_id:
            active_res = self.get_reg_host_ids(host_id=host_id)
            if active_res:
                return active_res[0], False
            hidden_res = self.get_hidden_host_ids(host_id=host_id)
            if hidden_res:
                return hidden_res[0], True
        elif cidr:
            active_res = self.get_reg_host_ids(cidr=cidr)
            if active_res:
                return active_res[0], False
            hidden_res = self.get_hidden_host_ids(cidr=cidr)
            if hidden_res:
                return hidden_res[0], True
        raise Exception("No registered device found for {}".format(cidr))

    def get_reg_host_ids(self, cidr=None, host_id=None):
        return self.get_host_ids(cidr=cidr, host_id=host_id, hidden=False)

    def get_hidden_host_ids(self, cidr=None, host_id=None):
        return self.get_host_ids(cidr=cidr, host_id=host_id, hidden=True)

    def get_host_ids(self, cidr=None, host_id=None, hidden=False):
        if hidden:
            url = utils.build_url(self.base_url, "/devices/queries/devices-hidden/v1", logger=self.logger)
        else:
            url = utils.build_url(self.base_url, "/devices/queries/devices/v1", logger=self.logger)
        params = {}
        if host_id:
            params["filter"] = "device_id:\"{}\"".format(host_id)
        elif cidr:
            params["filter"] = "local_ip:\"{}\"".format(cidr)
        reply = self.call_crowdstrike_api(url, "get", raw_url=True, params=params).json()
        hosts = reply.get("resources", [])
        return hosts

    def get_host_details(self, host_ids):
        url = utils.build_url(self.base_url, "/devices/entities/devices/v1", logger=self.logger)
        reply = self.call_crowdstrike_api(url, "get", raw_url=True, params={"ids": host_ids}).json()
        return reply.get("resources", [])

    def extract_message_from_action_reply(self, reply):
        if reply.status_code/100 == 2:
            return {"result_msg": "Action succeeded"}
        if reply.status_code == 409:
            return {"result_msg": "No action taken. Action previously performed"}
        try:
            errors = reply.json().get("errors", [])
        except Exception as e:
            raise Exception("Invalid response received from Crowdstrike server")
        raise Exception(json.dumps(errors))

    def call_crowdstrike_api(self, url, method, raw_url=False, params={}):
        """
        Make an API requests.
        :param url: string
        :param method: bool
        :return: response
        """
        if not raw_url:
            url = utils.build_url(self.base_url, "/sensors/entities/datafeed/v2", {"appId":"SIEM-Connector-JSON", "format":"json"}, logger=self.logger)
        if method == "get":
            status = requests.get(url, headers=self.headers, verify=False, params=params, timeout=120, proxies=self._proxy)
        else:
            status = requests.post(url, headers=self.headers, verify=False, json=params, timeout=120, proxies=self._proxy)
        return status

    def call_crowdstrike_action(self, ids="", action=None):
        """
        id_list hold the target agent ids: ["abcd","efgh"]
        action are for the following actions: 
            contain - This action contains the host, which stops any network communications to locations other than the CrowdStrike cloud and IPs specified in your containment policy
            lift_containment: This action lifts containment on the host, which returns its network communications to normal
            hide_host: This action will delete a host. After the host is deleted, no new detections for that host will be reported via UI or APIs
            unhide_host: This action will restore a host. Detection reporting will resume after the host is restored        
        :return: response
        """
        if action == "contain" or action =="lift_containment" or action == "hide_host" or action =="unhide_host":
            post_json = { "action_parameters": [], "ids": ["{}".format(ids)]}
            url = utils.build_url(self.base_url, "/devices/entities/devices-actions/v2", {"action_name": action}, logger=self.logger)
        else:
            print("illegal action")
            return
        response = self.call_crowdstrike_api(url, "post", raw_url=url, params=post_json)
        return response

if __name__ == '__main__':

    LOG_FILENAME = 'logs/crowdstrike_collector.log'
    MODULE = 'crowdstrike_collector'

    FORMAT = '%(asctime)-15s|%(name)s|%(levelname)s|%(message)s'

    logger = logging.getLogger(MODULE);
    logger.setLevel(logging.INFO)

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '--interval',
        help='The looking back minutes.')
    parser.add_argument(
        '--application',
        help='The application name: admin, calendar, drive etc.')

    args = parser.parse_args()

    if args.application is None:
        #threat, atp and log
        args.application = 'threat'
    if args.interval is None:
        interval = 5
    else:
        interval = int(args.interval)
    

    with open('ds_conf.yml') as f:
        sa_yml_info = yaml.safe_load(f)
        
    scc = CrowdStrikeConnector(tenant_id="", client_id=sa_yml_info["client_id"], password=sa_yml_info["password"], logger=logger)
    current_time = datetime.datetime.utcnow()
    end_time = str(current_time).replace(' ', 'T')+'Z'
    start_time = str(current_time - datetime.timedelta(minutes=interval)).replace(' ', 'T')+'Z'
    ret = scc.login()
    print(ret)
    payload ={"first_behavior": start_time}
    
    
    response = scc.call_crowdstrike_api( url="https://api.crowdstrike.com/devices/entities/devices/v1?ids={}".format('45e6a3ec056f4089a09ef7dcf0563d85'), method="get", raw_url=True, params=payload)
    print(json.dumps(response.json(), sort_keys=False, indent=4))
    ids = "45e6a3ec056f4089a09ef7dcf0563d85"
    action = "contain"
    #action = "lift_containment"
    #action = "hide_host"
    #action = "unhide_host"
    response = scc.call_crowdstrike_action(ids=ids, action=action)
    print(json.dumps(response.json(), sort_keys=False, indent=4))

    #response = scc.call_crowdstrike_api( url="https://api.crowdstrike.com/devices/queries/devices/v1?filter=last_seen:>='{}'".format(start_time), method="get", raw_url=True, params=payload)
    #print(json.dumps(response.json(), sort_keys=False, indent=4))
    #response = scc.call_crowdstrike_api( url="https://api.crowdstrike.com/detects/queries/detects/v1?offset={0}&limit={1}&filter=first_behavior:>='{2}'".format(0, 2, start_time), method="get", raw_url=True, params=payload)
    #print(json.dumps(response.json(), sort_keys=False, indent=4))
    #payload = {"ids": [] }
    #payload['ids'] = response.json()['resources']
    #print(payload)
    #response = scc.call_crowdstrike_api( url="https://api.crowdstrike.com/detects/entities/summaries/GET/v1", method="post", raw_url=True, params=payload)
    #print(json.dumps(response.json(), sort_keys=False, indent=4))
